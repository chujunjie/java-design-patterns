# 设计模式
## 创建型
* #### 单例模式(Singleton)
  确保有且只有一个对象被创建
* #### 工厂方法模式(FactoryMethod)
  由子类决定创建的具体类是哪一个
* #### 抽象工厂模式(AbstractFactory)
  允许客户创建对象的家族，而无需指定他们的具体类
* #### 生成器模式(Builder)*
  封装一个产品的结构过程，并允许按步骤构造
* #### 原型模式(Prototype)*
  向客户隐藏创建新实例的复杂性
## 结构型
* #### 装饰者模式(Decorator) 
  包装一个对象，已提供新的行为 
* #### 组合模式(Composite)
  客户用一致的方式处理对象集合和单个对象
* #### 适配器模式(Adapter)
  封装对象，并提供不同的接口
* #### 代理模式(Proxy)
  包装对象，以控制对此对象的访问
* #### 外观模式(Facade)
  简化一群类的接口
* #### 桥接模式(Bridge)*
  不仅改变实现，也改变抽象
* #### 享元模式(Flyweight)*
  让一个类的实例能够用来提供许多“虚拟实例”
## 行为型
* #### 状态模式(State)
  封装了基于状态的行为，并使用委托在行为之间切换
* #### 迭代器模式(Iterator)
  在对象的集合之间游走，而不暴露集合的实现
* #### 策略模式(Strategy)
  封装可以互换的行为，并使用委托决定要使用哪一个行为
* #### 观察者模式(Observer)
  让被观察对象能够在状态改变时通知观察者
* #### 模板方法模式(TemplateMethod)
  由子类决定如何实现一个算法中的步骤
* #### 命令模式(Command)
  封装请求为对象
* #### 中介者模式(Mediator)*
  集中相关对象之间复杂的沟通和控制方式
* #### 访问者模式(Visitor)*
  允许对组合结构加入新的操作，而无需改变结构本身
* #### 备忘录模式(Memento)*
  让对象返回之前的状态
* #### 解释器模式(Interpreter)*
  为语言创建解释器
* #### 责任链模式(Chain of Responsibility)*
  让一个以上的对象有机会处理某个请求
